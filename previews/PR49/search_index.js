var documenterSearchIndex = {"docs":
[{"location":"tutorials/error_recovery/#Guaranteed-Error-Recovery","page":"Minimum latency error recovery","title":"Guaranteed Error Recovery","text":"","category":"section"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"Safety-critical real-time systems are often required to have performance critical error-recovery logic. While errors are not supposed to occur, they sometimes do anyways ðŸ˜¦, and when they do, we may want to make sure that the recovery logic runs with minimum latency.","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"In the following example, we are executing a loop that may throw an error. By default check_allocs allows allocations on the error path, i.e., allocations that occur as a consequence of an exception being thrown. This can cause the garbage collector to be invoked by the allocation, and introduce an unbounded latency before we execute the error recovery logic.","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"To guard ourselves against this, we may follow these steps","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"Prove that the function does not allocate memory except for on exception paths.\nSince we have proved that we are not allocating memory, we may disable the garbage collector. This prevents it from running before the error recovery logic.\nTo make sure that the garbage collector is re-enabled after an error has been recovered from, we re-enable it in a finally block.","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"function treading_lightly()\n    a = 0.0\n    GC.enable(false) # Turn off the GC before entering the loop\n    try\n        for i = 10:-1:-1\n            a += sqrt(i) # This throws an error for negative values of i\n        end\n    catch\n        exit_gracefully() # This function is supposed to run with minimum latency\n    finally\n        GC.enable(true) # Always turn the GC back on before exiting the function\n    end\n    a\nend\nexit_gracefully() = println(\"Calling mother\")\n\nusing AllocCheck, Test\nallocs = check_allocs(treading_lightly, ()) # Check that it's safe to proceed","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"@test isempty(allocs)","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"check_allocs returned zero allocations. If we invoke check_allocs with the flag ignore_throw = false, we will see that the function may allocate memory on the error path:","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"allocs = check_allocs(treading_lightly, (); ignore_throw = false)\nlength(allocs)","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"Finally, we test that the function is producing the expected result:","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"val = treading_lightly()\n@test val â‰ˆ 22.468278186204103  # hide","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"In this example, we accepted an allocation on the exception path with the motivation that it occurred once only, after which the program was terminated. Implicit in this approach is an assumption that the exception path does not allocate too much memory to execute the error recovery logic before the garbage collector is turned back on. We should thus convince ourselves that this assumption is valid, e.g., by means of testing:","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"treading_lightly() # Warm start\nallocated_memory = @allocated treading_lightly() # A call that triggers the exception path\n# @test allocated_memory < 1e4","category":"page"},{"location":"tutorials/error_recovery/","page":"Minimum latency error recovery","title":"Minimum latency error recovery","text":"The allocations sites reported with the flag ignore_throw = false may be used as a guide as to what to test.","category":"page"},{"location":"api/#Exported-functions-and-types","page":"API","title":"Exported functions and types","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Docstrings","page":"API","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AllocCheck.check_allocs","category":"page"},{"location":"api/#AllocCheck.check_allocs","page":"API","title":"AllocCheck.check_allocs","text":"check_allocs(func, types; ignore_throw=true)\n\nCompiles the given function and types to LLVM IR and checks for allocations.\n\nReturns a vector of AllocationSite, DynamicDispatch, and AllocatingRuntimeCall\n\nwarning: Warning\nThe Julia language/compiler does not guarantee that this result is stable across Julia invocations. If you rely on allocation-free code for safety/correctness, it is not enough to check check_allocs(foo, ...) in test code and expect that the corresponding call in production will not allocate at runtime.For this case, you must use @check_allocs instead.\n\nExample\n\njulia> function foo(x::Int, y::Int)\n           z = x + y\n           return z\n       end\nfoo (generic function with 1 method)\n\njulia> allocs = check_allocs(foo, (Int, Int))\nAllocCheck.AllocationSite[]\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"AllocCheck.@check_allocs","category":"page"},{"location":"api/#AllocCheck.@check_allocs","page":"API","title":"AllocCheck.@check_allocs","text":"@check_allocs ignore_throw=true (function def)\n\nWraps the provided function definition so that all calls to it will be automatically checked for allocations.\n\nIf the check fails, an AllocCheckFailure exception is thrown containing the detailed failures, including the backtrace for each defect.\n\nNote: All calls to the wrapped function are effectively a dynamic dispatch, which means they are type-unstable and may allocate memory at function entry. @check_allocs only guarantees the absence of allocations after the function has started running.\n\nExample\n\njulia> @check_allocs multiply(x,y) = x*y\nmultiply (generic function with 1 method)\n\njulia> multiply(1.5, 3.5) # no allocations for Float64\n5.25\n\njulia> multiply(rand(3,3), rand(3,3)) # matmul needs to allocate the result\nERROR: @check_alloc function contains 1 allocations.\n\nStacktrace:\n [1] macro expansion\n   @ ~/repos/AllocCheck/src/macro.jl:134 [inlined]\n [2] multiply(x::Matrix{Float64}, y::Matrix{Float64})\n   @ Main ./REPL[2]:133\n [3] top-level scope\n   @ REPL[5]:1\n\n\n\n\n\n","category":"macro"},{"location":"tutorials/optional_debugging_and_logging/#Optional-debugging-and-logging","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"","category":"section"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"For debugging purposes, it may sometimes be beneficial to include logging statements in a function, for example","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"using AllocCheck # hide\n@check_allocs function myfun(verbose::Bool)\n    a = 0.0\n    for i = 1:3\n        a = a + i\n        verbose && @info \"a = $a\"\n    end\nend\nnothing # hide","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"Here, the printing of some relevant information is only performed if verbose = true. While the printing is optional, and not performed if verbose = false, check_allocs operates on types rather than values, i.e., check_allocs only knows that the argument is of type Bool, not that it may have the value false:","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"myfun(false)","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"Indeed, this function was determined to potentially allocate memory.","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"To allow such optional features while still being able to prove that a function does not allocate if the allocating features are turned off, we may lift the value true into the type domain, we do this by means of the Val type:","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"function typed_myfun(::Val{verbose}) where verbose\n    a = 0.0\n    for i = 1:3\n        a = a + i\n        verbose && @info \"a = $a\"\n    end\nend\n\nlength(check_allocs(typed_myfun, (Val{false},)))","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"The compiler, and thus also AllocCheck, now knows that the value of verbose is false, since this is encoded in the type Val{false}. The compiler can use this knowledge to figure out that the @info statement won't be executed, and thus prove that the function will not allocate memory.","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"The user may still use this function with the debug print enabled by calling it like","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"typed_myfun(Val{true}())","category":"page"},{"location":"tutorials/optional_debugging_and_logging/#Advanced:-Constant-propagation","page":"Optional debugging and logging","title":"Advanced: Constant propagation","text":"","category":"section"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"Sometimes, code written without this trick will still work just fine with AllocCheck.","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"That's because in some limited scenarios, the compiler is able to use constant propagation to determine what path through a program will be taken based on the value of constants.","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"We demonstrate this effect below, where the value verbose = false is hard-coded into the function:","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"@check_allocs function constant_myfun()\n    verbose = false\n    a = 0.0\n    for i = 1:3\n        a = a + i\n        verbose && @info \"a = $a\"\n    end\n    return a\nend\n\nconstant_myfun()","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"When looking at constant_myfun, the compiler knows that verbose = false since this constant is hard coded into the program. Sometimes, the compiler can even propagate constant values all the way into called functions.","category":"page"},{"location":"tutorials/optional_debugging_and_logging/","page":"Optional debugging and logging","title":"Optional debugging and logging","text":"This is useful, but it's not guaranteed to happen in general. The Val{T} trick described here ensures that the variable is propagated as a constant everywhere it is required.","category":"page"},{"location":"#AllocCheck","page":"Home","title":"AllocCheck","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AllocCheck.jl is a Julia package that statically checks if a function call may allocate, analyzing the generated LLVM IR of it and it's callees using LLVM.jl and GPUCompiler.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"AllocCheck operates on functions, trying to statically determine wether or not a function may allocate memory, and if so, where that allocation appears. This is different from measuring allocations using, e.g., @time or @allocated, which measures the allocations that did happen during the execution of a function.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The primary entry point to check allocations is the macro @check_allocs which is used to annotate a function definition that you'd like to enforce allocation checks for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using AllocCheck\nusing Test # hide\n@check_allocs mymod(x) = mod(x, 2.5)\n\nmymod(1.5) # call automatically checked for allocations","category":"page"},{"location":"","page":"Home","title":"Home","text":"This call happened without error, indicating that the function was proven to not allocate any memory after it starts ðŸŽ‰","category":"page"},{"location":"","page":"Home","title":"Home","text":"When used on a function that may allocate memory","category":"page"},{"location":"","page":"Home","title":"Home","text":"@check_allocs linsolve(a, b) = a \\ b\n\nlinsolve(rand(10,10), rand(10))","category":"page"},{"location":"","page":"Home","title":"Home","text":"the function call raises an AllocCheckFailure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The errors field allows us to inspect the individual errors to get some useful information. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"try\n  linsolve(rand(10,10), rand(10))\ncatch err\n  err.errors[1]\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"we see what type of object was allocated, and where in the code the allocation appeared.","category":"page"},{"location":"#Functions-that-throw-exceptions","page":"Home","title":"Functions that throw exceptions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some functions that we do not expect may allocate memory, like sin, actually may:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@allocated try sin(Inf) catch end","category":"page"},{"location":"","page":"Home","title":"Home","text":"The reason for this is that sin needs to allocate if it throws an error.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, @check_allocs ignores all such allocations and assumes that no exceptions are thrown. If you care about detecting these allocations anyway, you can use ignore_throw=false:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@check_allocs mysin1(x) = sin(x)\n@check_allocs ignore_throw=false mysin2(x) = sin(x)\n\n@test mysin1(1.5) == sin(1.5)\n@test_throws AllocCheckFailure mysin2(1.5)","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Every call into a @check_allocs function behaves like a dynamic dispatch. This means that it can trigger compilation dynamically (involving lots of allocation), and even when the function has already been compiled, a small amount of allocation is still expected on function entry.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For most applications, the solution is to use @check_allocs to wrap your top-level entry point or your main application loop, in which case those applications are only incurred once. @check_allocs will guarantee that no dynamic compilation or allocation occurs once your function has started running.","category":"page"},{"location":"tutorials/hot_loop/#Allocations-followed-by-a-hot-loop","page":"Hot loops","title":"Allocations followed by a hot loop","text":"","category":"section"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"A common pattern in high-performance Julia code, as well as in real-time systems, is to initially allocate some working memory, followed by the execution of a performance sensitive hot loop that should perform no allocations. In the example below, we show a function run_almost_forever that resembles the implementation of a simple control system. The function starts by allocating a large logvector in which some measurement data is to be saved, followed by the execution of a loop which should run with as predictable timing as possible, i.e., we do not want to perform any allocations or invoke the garbage collector while executing the loop.","category":"page"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"function run_almost_forever()\n    N = 100_000 # A large number\n    logvector = zeros(N) # Allocate a large vector for storing results\n    for i = 1:N # Run a hot loop that may not allocate\n        y = sample_measurement()\n        logvector[i] = y\n        u = controller(y)\n        apply_control(u)\n        Libc.systemsleep(0.01)\n    end\nend\n\n# Silly implementations of the functions used in the example\nsample_measurement() = 2.0\ncontroller(y) = -2y\napply_control(u) = nothing\nnothing # hide","category":"page"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"Here, the primary concern is the loop, while the preamble of the function should be allowed to allocate memory. The recommended strategy in this case is to refactor the function into a separate preamble and loop, like this","category":"page"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"function run_almost_forever2() # The preamble that performs allocations\n    N = 100_000 # A large number\n    logvector = zeros(N) # Allocate a large vector for storing results\n    run_almost_forever!(logvector)\nend\n\nfunction run_almost_forever!(logvector) # The hot loop that is allocation free\n    for i = eachindex(logvector) # Run a hot loop that may not allocate\n        y = sample_measurement()\n        @inbounds logvector[i] = y\n        u = controller(y)\n        apply_control(u)\n        Libc.systemsleep(0.01)\n    end\nend\nnothing # hide","category":"page"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"We may now analyze the loop function run_almost_forever! to verify that it does not allocate memory:","category":"page"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"using AllocCheck, Test\nallocs = check_allocs(run_almost_forever!, (Vector{Float64},));\n@test isempty(allocs)","category":"page"},{"location":"tutorials/hot_loop/#More-complicated-initialization","page":"Hot loops","title":"More complicated initialization","text":"","category":"section"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"In practice, a function may need to perform several distinct allocations upfront, including potentially allocating objects of potentially complicated types, like closures etc. In situations like this, the following pattern may be useful:","category":"page"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"struct Workspace\n    # All you need to run the hot loop, for example:\n    cache1::Vector{Float64}\n    cache2::Matrix{Float64}\nend\n\nfunction setup(max_iterations::Int = 100_000)\n    # Allocate and initialize the workspace\n    cache1 = zeros(max_iterations)\n    cache2 = zeros(max_iterations, max_iterations)\n    return Workspace(cache1, cache2)\nend\n\nfunction run!(workspace::Workspace)\n    # The hot loop\n    for i = eachindex(workspace.cache1)\n        workspace.cache1[i] = my_important_calculation() # The allocated cache is modified in place\n        ...\n    end\nend\n\nfunction run()\n    workspace = setup()\n    run!(workspace)\nend","category":"page"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"Here, workspace is a custom struct designed to serve as a workspace for the hot loop, but it could also be realized as a simple tuple of all the allocated objects required for the computations. Note, the struct Workspace in this example was not marked as mutable. However, its contents, the two cache arrays, are. This means that the run! function may modify the contents of the cache arrays.","category":"page"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"The benefit of breaking the function up into two parts which are called from a third, is that we may now create the workspace object individually, and use it to compute the type of the arguments to the run! function that we are interested in analyzing:","category":"page"},{"location":"tutorials/hot_loop/","page":"Hot loops","title":"Hot loops","text":"workspace = setup()\nallocs = check_allocs(run!, (typeof(workspace),))","category":"page"}]
}
